#!/bin/bash

# Couleurs et styles
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
DIM='\033[2m'
ITALIC='\033[3m'
UNDERLINE='\033[4m'
BLINK='\033[5m'
BG_BLUE='\033[44m'
NC='\033[0m'

# Symboles
CHECK="âœ“"
CROSS="âœ—"
ARROW="âžœ"
STAR="â˜…"
DOT="â€¢"
BRANCH="âŽ‡"
ROCKET="ðŸš€"
SPARKLES="âœ¨"
GEAR="âš™ï¸"
LIGHTNING="âš¡"

# Logo ASCII
function print_logo() {
    echo -e "${BLUE}${BOLD}"
    echo "    ________  ______           __"
    echo "   / ____/ _/ / __/___ ______/ /_"
    echo "  / / __/ /_  / /_/ __ \`/ ___/ __/"
    echo " / /_/ / __/ / __/ /_/ (__  ) /_"
    echo " \____/_/   /_/  \__,_/____/\__/"
    echo -e "${NC}\n"
    echo -e "${DIM}Version 1.0.0${NC}"
    print_separator
}

# Fonction pour afficher une ligne de sÃ©paration
function print_separator() {
    echo -e "${DIM}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
}

# Fonction pour afficher un cadre
function print_box() {
    local text=$1
    local width=$((${#text} + 4))
    echo -e "${DIM}â”Œ$("printf 'â”€%.0s' $(seq 1 $width))â”${NC}"
    echo -e "${DIM}â”‚${NC}  ${text}  ${DIM}â”‚${NC}"
    echo -e "${DIM}â””$("printf 'â”€%.0s' $(seq 1 $width))â”˜${NC}"
}

# Animation de chargement
function show_spinner() {
    local pid=$1
    local message=$2
    local spin='-\|/'
    local i=0
    while kill -0 $pid 2>/dev/null; do
        i=$(( (i+1) %4 ))
        printf "\r${BLUE}${GEAR} ${message} ${BLINK}${spin:$i:1}${NC}"
        sleep .1
    done
    printf "\r"
}

# Fonction pour afficher un titre
function print_title() {
    print_separator
    echo -e "${BOLD}${BG_BLUE}${WHITE}  $1  ${NC}"
    print_separator
}

# Fonction pour afficher une option de menu
function print_option() {
    local number=$1
    local text=$2
    local default=$3
    if [ -n "$default" ]; then
        echo -e "${CYAN}${STAR} $number.${NC} $text ${DIM}[dÃ©faut]${NC}"
    else
        echo -e "${CYAN}${DOT} $number.${NC} $text"
    fi
}

# Messages d'Ã©tat
function success_msg() {
    echo -e "\n${GREEN}${SPARKLES} $1 ${SPARKLES}${NC}\n"
}

function error_msg() {
    echo -e "\n${RED}${CROSS} $1 ${CROSS}${NC}\n"
}

function warning_msg() {
    echo -e "\n${YELLOW}${LIGHTNING} $1${NC}\n"
}

function info_msg() {
    echo -e "\n${BLUE}${ROCKET} $1${NC}\n"
}

# Fonction pour lire l'entrÃ©e utilisateur
function read_input() {
    local prompt=$1
    local var_name=$2
    
    echo -e "${MAGENTA}${ARROW}${NC} ${ITALIC}${prompt}${NC} ${DIM}(r pour retour)${NC}: " >&2
    read -r response
    
    if [ "$response" = "r" ] || [ "$response" = "R" ]; then
        return 1
    fi
    
    eval "$var_name=\"$response\""
    return 0
}

# Fonction pour vÃ©rifier les modifications
function check_changes() {
    if [ -z "$(git status --porcelain)" ]; then
        error_msg "Aucune modification Ã  commiter."
        return 1
    fi
    return 0
}

# Fonction pour vÃ©rifier si les fichiers sont stagÃ©s
function check_staged() {
    if [ -z "$(git diff --cached --name-only)" ]; then
        error_msg "Aucun fichier n'est stagÃ© pour le commit."
        return 1
    fi
    return 0
}

# Fonction pour choisir le type de commit
function choose_commit_type() {
    while true; do
        echo -e "${ITALIC}Choisissez le type de votre commit :${NC}"
        echo "1. feat : Nouvelle fonctionnalitÃ©"
        echo "2. fix : Correction de bug"
        echo "3. docs : Modification de la documentation"
        echo "4. style : Formatage du code"
        echo "5. refactor : Restructuration du code"
        echo "6. test : Ajout ou modification de tests"
        echo "7. chore : TÃ¢ches diverses"
        
        read_input "Choisissez une option (1/2/3/4/5/6/7)" commit_type
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        case $commit_type in
            1) type="feat" ;;
            2) type="fix" ;;
            3) type="docs" ;;
            4) type="style" ;;
            5) type="refactor" ;;
            6) type="test" ;;
            7) type="chore" ;;
            *) error_msg "Option invalide." ; continue ;;
        esac
        
        read_input "Entrez le scope (optionnel, appuyez sur EntrÃ©e pour ignorer)" scope
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        read_input "Entrez la description du commit" description
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        # Construire le message de commit
        if [ -n "$scope" ]; then
            commit_msg="$type($scope) $description"
        else
            commit_msg="$type: $description"
        fi
        
        return 0
    done
}

# Fonction pour commit
function commit_changes() {
    # VÃ©rifier si des fichiers sont stagÃ©s
    if ! check_staged; then
        return 1
    fi
    
    # Choisir le type de commit et construire le message
    if ! choose_commit_type; then
        return 1
    fi
    
    # Effectuer le commit
    git commit -m "$commit_msg" &
    show_spinner $! "CrÃ©ation du commit"
    wait $!
    
    if ! check_command "Impossible de crÃ©er le commit."; then
        return 1
    fi
    
    success_msg "Commit crÃ©Ã© avec succÃ¨s."
    return 0
}

# Fonction pour vÃ©rifier si le remote existe
function check_remote() {
    if ! git remote | grep -q "^origin$"; then
        error_msg "Aucun remote 'origin' configurÃ©."
        return 1
    fi
    return 0
}

# Fonction pour push
function push_changes() {
    # VÃ©rifier si le remote existe
    if ! check_remote; then
        return 1
    fi
    
    while true; do
        # Essayer de push
        if git push origin HEAD; then
            success_msg "Push rÃ©ussi."
            return 0
        else
            # En cas d'erreur, proposer des options
            echo -e "${ITALIC}Erreur lors du push. Que voulez-vous faire ?${NC}"
            echo "1. RÃ©essayer"
            echo "2. Pull puis Push (avec rebase)"
            echo "3. Force Push (ATTENTION: peut Ã©craser les changements distants)"
            echo "4. Annuler"
            
            read_input "Choisissez une option (1/2/3/4)" push_option
            if [ $? -eq 1 ]; then
                return 1
            fi
            
            case $push_option in
                1) continue ;;
                2)
                    git pull --rebase origin HEAD &
                    show_spinner $! "Pull des changements"
                    wait $!
                    
                    if ! check_command "Impossible de pull les changements."; then
                        continue
                    fi
                    ;;
                3)
                    warning_msg "Le force push peut Ã©craser les changements distants!"
                    read_input "ÃŠtes-vous sÃ»r ? (oui/non)" confirm_force
                    if [ $? -eq 1 ] || [ "$confirm_force" != "oui" ]; then
                        continue
                    fi
                    git push -f origin HEAD &
                    show_spinner $! "Force push"
                    wait $!
                    
                    if ! check_command "Force push Ã©chouÃ©."; then
                        continue
                    fi
                    success_msg "Force push rÃ©ussi."
                    return 0
                    ;;
                4) return 1 ;;
                *) error_msg "Option invalide." ; continue ;;
            esac
        fi
    done
}

# Fonction pour vÃ©rifier si le dossier est vide (en ignorant .git)
function is_directory_empty() {
    [ -z "$(ls -A | grep -v '^\.git$')" ]
}

# Fonction principale
function main() {
    # VÃ©rifier si le rÃ©pertoire est vide (en ignorant .git)
    if is_directory_empty; then
        # Si le rÃ©pertoire est vide, proposer de cloner ou d'initialiser
        if ! setup_git; then
            return 1
        fi
    elif [ ! -d ".git" ]; then
        # Si le rÃ©pertoire n'est pas vide mais pas de .git, proposer d'initialiser
        if ! setup_git; then
            return 1
        fi
    fi
    
    # Ajouter les fichiers
    if ! add_files; then
        return 1
    fi
    
    # CrÃ©er le commit
    if ! commit_changes; then
        return 1
    fi
    
    # Push les changements
    if ! push_changes; then
        return 1
    fi
    
    success_msg "OpÃ©ration terminÃ©e avec succÃ¨s!"
    return 0
}

# Fonction pour gÃ©rer l'initialisation ou le clonage
function setup_git() {
    print_logo
    print_title "Configuration Git"
    print_box "Que souhaitez-vous faire ?"
    echo
    print_option "1" "Cloner un repository"
    print_option "2" "Initialiser un nouveau dÃ©pÃ´t Git" "true"
    echo
    read_input "Choisissez une option (1/2)" choice
    if [ $? -eq 1 ]; then
        return 1
    fi
    
    choice=${choice:-2}
    if [ "$choice" = "1" ]; then
        info_msg "Configuration du clonage..."
        clone_repository
    else
        info_msg "Initialisation d'un nouveau dÃ©pÃ´t..."
        init_git
    fi
    return 0
}

# Fonction pour cloner un repository
function clone_repository() {
    print_title "Clonage du Repository"
    read_input "Entrez l'URL du repository Ã  cloner" clone_url
    if [ $? -eq 1 ]; then
        return 1
    fi
    
    info_msg "Clonage en cours..."
    git clone "$clone_url" . &
    show_spinner $! "Clonage du repository"
    wait $!
    
    if ! check_command "Impossible de cloner le repository."; then
        return 1
    fi
    success_msg "Repository clonÃ© avec succÃ¨s"
    create_gitignore
    return 0
}

# Fonction pour initialiser Git
function init_git() {
    print_title "Initialisation Git"
    info_msg "Initialisation du dÃ©pÃ´t Git..."
    git init &
    show_spinner $! "Initialisation du dÃ©pÃ´t"
    wait $!
    
    if ! check_command "Impossible d'initialiser le dÃ©pÃ´t Git."; then
        return 1
    fi
    success_msg "DÃ©pÃ´t Git initialisÃ© avec succÃ¨s"
    
    create_gitignore
    
    print_title "Configuration du Remote"
    print_box "Voulez-vous configurer un remote ?"
    echo
    print_option "1" "Oui" "true"
    print_option "2" "Non"
    echo
    read_input "Choisissez une option (1/2)" config_remote
    if [ $? -eq 1 ]; then
        return 1
    fi
    config_remote=${config_remote:-1}
    
    if [ "$config_remote" = "1" ]; then
        read_input "Entrez l'URL du remote (ex: https://github.com/user/repo.git)" remote_url
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        if git remote | grep -q "^origin$"; then
            warning_msg "Le remote 'origin' existe dÃ©jÃ "
            print_box "Voulez-vous le remplacer ?"
            echo
            print_option "1" "Oui"
            print_option "2" "Non"
            echo
            read_input "Choisissez une option (1/2)" replace_remote
            if [ $? -eq 1 ]; then
                return 1
            fi
            if [ "$replace_remote" = "1" ]; then
                git remote remove origin
            else
                return 0
            fi
        fi
        
        info_msg "Configuration du remote..."
        git remote add origin "$remote_url" &
        show_spinner $! "Configuration du remote"
        wait $!
        
        if ! check_command "Impossible d'ajouter le remote."; then
            return 1
        fi
        success_msg "Remote configurÃ© avec succÃ¨s"
    fi
    return 0
}

# Fonction pour crÃ©er le .gitignore
function create_gitignore() {
    if [ ! -f ".gitignore" ]; then
        info_msg "CrÃ©ation du fichier .gitignore..."
        cat > .gitignore << 'EOL' &
.DS_Store
*.log
*.tmp
EOL
        show_spinner $! "CrÃ©ation du .gitignore"
        wait $!
        success_msg "Fichier .gitignore crÃ©Ã© avec les rÃ¨gles par dÃ©faut"
    fi
}

# Fonction pour ajouter les fichiers
function add_files() {
    print_title "Ajout des Fichiers"
    if [ ! -d ".git" ]; then
        error_msg "Pas de dÃ©pÃ´t Git trouvÃ©"
        return 1
    fi
    
    if ! check_changes; then
        return 1
    fi
    
    print_box "Que voulez-vous ajouter ?"
    echo
    print_option "1" "Tout ajouter (git add .)" "true"
    print_option "2" "SÃ©lectionner des fichiers spÃ©cifiques"
    echo
    read_input "Choisissez une option (1/2)" option
    if [ $? -eq 1 ]; then
        return 1
    fi
    
    option=${option:-1}
    if [ "$option" = "1" ]; then
        info_msg "Ajout de tous les fichiers..."
        git add . &
        show_spinner $! "Ajout des fichiers"
        wait $!
        
        if ! check_command "Impossible d'ajouter les fichiers."; then
            return 1
        fi
        success_msg "Tous les fichiers ont Ã©tÃ© ajoutÃ©s"
    else
        echo -e "\n${ITALIC}Voici les fichiers modifiÃ©s :${NC}"
        git status -s
        read_input "Entrez les numÃ©ros des fichiers Ã  ajouter (ex: 1 2 3)" files
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        for file in $files; do
            file_path=$(sed -n "${file}p" <<< "$(git status -s | cut -c4-)")
            info_msg "Ajout de $file_path..."
            git add "$file_path" &
            show_spinner $! "Ajout de $file_path"
            wait $!
            
            if ! check_command "Impossible d'ajouter le fichier: $file_path"; then
                return 1
            fi
        done
        success_msg "Les fichiers sÃ©lectionnÃ©s ont Ã©tÃ© ajoutÃ©s"
    fi
    return 0
}

# Lancer le script
main
