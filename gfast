#!/bin/bash

# Couleurs pour les messages
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Symboles
CHECK="✓"
CROSS="✗"
ARROW="➜"
DOT="•"

# Fonction pour afficher les messages d'erreur
function error_msg() {
    echo -e "${RED}Erreur: $1${NC}"
}

# Fonction pour afficher les messages de succès
function success_msg() {
    echo -e "${GREEN}Succès: $1${NC}"
}

# Fonction pour afficher les avertissements
function warning_msg() {
    echo -e "${YELLOW}Attention: $1${NC}"
}

# Fonction pour afficher les informations
function info_msg() {
    echo -e "${BLUE}Info: $1${NC}"
}

# Fonction pour vérifier si une commande a réussi
function check_command() {
    if [ $? -ne 0 ]; then
        error_msg "$1"
        return 1
    fi
    return 0
}

# Fonction pour lire l'entrée avec option de retour
function read_input() {
    local prompt=$1
    local var_name=$2
    while true; do
        read -p "${MAGENTA}${ARROW}${NC} $prompt (r pour retour): " input
        if [ "$input" = "r" ]; then
            return 1
        fi
        eval "$var_name='$input'"
        return 0
    done
}

# Fonction pour créer le .gitignore par défaut
function create_gitignore() {
    if [ ! -f ".gitignore" ]; then
        cat > .gitignore << 'EOL'
.DS_Store
*.log
*.tmp
EOL
        success_msg "Fichier .gitignore créé avec les règles par défaut."
    fi
}

# Fonction pour cloner un repository
function clone_repository() {
    read_input "Entrez l'URL du repository à cloner" clone_url
    if [ $? -eq 1 ]; then
        return 1
    fi
    
    info_msg "Clonage en cours..."
    git clone "$clone_url" .
    if ! check_command "Impossible de cloner le repository."; then
        return 1
    fi
    success_msg "Repository cloné avec succès."
    create_gitignore
    return 0
}

# Fonction pour initialiser Git
function init_git() {
    info_msg "Initialisation du dépôt Git..."
    git init
    if ! check_command "Impossible d'initialiser le dépôt Git."; then
        return 1
    fi
    success_msg "Dépôt Git initialisé avec succès."
    
    # Créer le .gitignore
    create_gitignore
    
    while true; do
        echo "Voulez-vous configurer un remote ?"
        echo "${CYAN}1.${NC} Oui [défaut]"
        echo "${CYAN}2.${NC} Non"
        read_input "Choisissez une option (1/2)" config_remote
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        config_remote=${config_remote:-1}
        
        if [ "$config_remote" = "1" ]; then
            read_input "Entrez l'URL du remote (ex: https://github.com/user/repo.git)" remote_url
            if [ $? -eq 1 ]; then
                continue
            fi
            
            # Vérifier si le remote existe déjà
            if git remote | grep -q "^origin$"; then
                warning_msg "Le remote 'origin' existe déjà."
                echo "Voulez-vous le remplacer ?"
                echo "${CYAN}1.${NC} Oui"
                echo "${CYAN}2.${NC} Non"
                read_input "Choisissez une option (1/2)" replace_remote
                if [ $? -eq 1 ]; then
                    continue
                fi
                if [ "$replace_remote" = "1" ]; then
                    git remote remove origin
                else
                    continue
                fi
            fi
            
            info_msg "Configuration du remote..."
            git remote add origin "$remote_url"
            if ! check_command "Impossible d'ajouter le remote."; then
                continue
            fi
            success_msg "Remote configuré avec succès."
        fi
        break
    done
    return 0
}

# Fonction pour gérer l'initialisation ou le clonage
function setup_git() {
    echo "Que souhaitez-vous faire ?"
    echo "${CYAN}1.${NC} Cloner un repository"
    echo "${CYAN}2.${NC} Initialiser un nouveau dépôt Git [défaut]"
    read_input "Choisissez une option (1/2)" choice
    if [ $? -eq 1 ]; then
        return 1
    fi
    
    choice=${choice:-2}
    if [ "$choice" = "1" ]; then
        clone_repository
    else
        init_git
    fi
    return 0
}

# Fonction pour vérifier les modifications
function check_changes() {
    if [ -z "$(git status --porcelain)" ]; then
        error_msg "Aucune modification à commiter."
        return 1
    fi
    return 0
}

# Fonction pour ajouter les fichiers
function add_files() {
    # Vérifier si on est dans un repo git
    if [ ! -d ".git" ]; then
        error_msg "Pas de dépôt Git trouvé."
        return 1
    fi

    # Vérifier s'il y a des modifications
    if ! check_changes; then
        return 1
    fi

    while true; do
        echo "Que voulez-vous ajouter ?"
        echo "${CYAN}1.${NC} Tout ajouter (git add .) [défaut]"
        echo "${CYAN}2.${NC} Sélectionner des fichiers spécifiques"
        read_input "Choisissez une option (1/2)" option
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        # Si l'option est vide, utiliser l'option 1 par défaut
        option=${option:-1}

        if [ "$option" = "1" ]; then
            info_msg "Ajout de tous les fichiers..."
            git add .
            if ! check_command "Impossible d'ajouter les fichiers."; then
                continue
            fi
            success_msg "Tous les fichiers ont été ajoutés."
            break
        elif [ "$option" = "2" ]; then
            echo "Voici les fichiers modifiés:"
            git status -s
            read_input "Entrez les numéros des fichiers à ajouter (ex: 1 2 3)" files
            if [ $? -eq 1 ]; then
                continue
            fi
            
            # Vérifier si la sélection est valide
            total_files=$(git status -s | wc -l)
            for file in $files; do
                if ! [[ "$file" =~ ^[0-9]+$ ]] || [ "$file" -gt "$total_files" ] || [ "$file" -lt 1 ]; then
                    error_msg "Sélection invalide: $file"
                    continue 2
                fi
            done
            
            for file in $files; do
                file_path=$(sed -n "${file}p" <<< "$(git status -s | cut -c4-)")
                info_msg "Ajout de $file_path..."
                git add "$file_path"
                if ! check_command "Impossible d'ajouter le fichier: $file_path"; then
                    continue 2
                fi
            done
            success_msg "Les fichiers sélectionnés ont été ajoutés."
            break
        else
            error_msg "Option invalide."
            continue
        fi
    done
    return 0
}

# Fonction pour vérifier si les fichiers sont stagés
function check_staged() {
    if [ -z "$(git diff --cached --name-only)" ]; then
        error_msg "Aucun fichier n'est stagé pour le commit."
        return 1
    fi
    return 0
}

# Fonction pour choisir le type de commit
function choose_commit_type() {
    while true; do
        echo "Choisissez le type de votre commit :"
        echo "${CYAN}1.${NC} feat : Nouvelle fonctionnalité"
        echo "${CYAN}2.${NC} fix : Correction de bug"
        echo "${CYAN}3.${NC} docs : Modification de la documentation"
        echo "${CYAN}4.${NC} style : Formatage du code"
        echo "${CYAN}5.${NC} refactor : Restructuration du code"
        echo "${CYAN}6.${NC} test : Ajout ou modification de tests"
        echo "${CYAN}7.${NC} chore : Tâches diverses"
        
        read_input "Choisissez une option (1/2/3/4/5/6/7)" commit_type
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        case $commit_type in
            1) type="feat" ;;
            2) type="fix" ;;
            3) type="docs" ;;
            4) type="style" ;;
            5) type="refactor" ;;
            6) type="test" ;;
            7) type="chore" ;;
            *) error_msg "Option invalide." ; continue ;;
        esac
        
        read_input "Entrez le scope (optionnel, appuyez sur Entrée pour ignorer)" scope
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        read_input "Entrez la description du commit" description
        if [ $? -eq 1 ]; then
            return 1
        fi
        
        # Construire le message de commit
        if [ -n "$scope" ]; then
            commit_msg="$type($scope) $description"
        else
            commit_msg="$type: $description"
        fi
        
        return 0
    done
}

# Fonction pour commit
function commit_changes() {
    # Vérifier si des fichiers sont stagés
    if ! check_staged; then
        return 1
    fi
    
    # Choisir le type de commit et construire le message
    if ! choose_commit_type; then
        return 1
    fi
    
    # Effectuer le commit
    info_msg "Création du commit..."
    git commit -m "$commit_msg"
    if ! check_command "Impossible de créer le commit."; then
        return 1
    fi
    
    success_msg "Commit créé avec succès."
    return 0
}

# Fonction pour vérifier si le remote existe
function check_remote() {
    if ! git remote | grep -q "^origin$"; then
        error_msg "Aucun remote 'origin' configuré."
        return 1
    fi
    return 0
}

# Fonction pour push
function push_changes() {
    # Vérifier si le remote existe
    if ! check_remote; then
        return 1
    fi
    
    while true; do
        # Essayer de push
        info_msg "Push en cours..."
        if git push origin HEAD; then
            success_msg "Push réussi."
            return 0
        else
            # En cas d'erreur, proposer des options
            echo "Erreur lors du push. Que voulez-vous faire ?"
            echo "${CYAN}1.${NC} Réessayer"
            echo "${CYAN}2.${NC} Pull puis Push (avec rebase)"
            echo "${CYAN}3.${NC} Force Push (ATTENTION: peut écraser les changements distants)"
            echo "${CYAN}4.${NC} Annuler"
            
            read_input "Choisissez une option (1/2/3/4)" push_option
            if [ $? -eq 1 ]; then
                return 1
            fi
            
            case $push_option in
                1) continue ;;
                2)
                    info_msg "Pull des changements..."
                    git pull --rebase origin HEAD
                    if ! check_command "Impossible de pull les changements."; then
                        continue
                    fi
                    ;;
                3)
                    warning_msg "Le force push peut écraser les changements distants!"
                    read_input "Êtes-vous sûr ? (oui/non)" confirm_force
                    if [ $? -eq 1 ] || [ "$confirm_force" != "oui" ]; then
                        continue
                    fi
                    info_msg "Force push en cours..."
                    git push -f origin HEAD
                    if ! check_command "Force push échoué."; then
                        continue
                    fi
                    success_msg "Force push réussi."
                    return 0
                    ;;
                4) return 1 ;;
                *) error_msg "Option invalide." ; continue ;;
            esac
        fi
    done
}

# Fonction pour vérifier si le dossier est vide (en ignorant .git)
function is_directory_empty() {
    [ -z "$(ls -A | grep -v '^\.git$')" ]
}

# Fonction principale
function main() {
    # Vérifier si le répertoire est vide (en ignorant .git)
    if is_directory_empty; then
        # Si le répertoire est vide, proposer de cloner ou d'initialiser
        if ! setup_git; then
            return 1
        fi
    elif [ ! -d ".git" ]; then
        # Si le répertoire n'est pas vide mais pas de .git, proposer d'initialiser
        if ! setup_git; then
            return 1
        fi
    fi
    
    # Ajouter les fichiers
    if ! add_files; then
        return 1
    fi
    
    # Créer le commit
    if ! commit_changes; then
        return 1
    fi
    
    # Push les changements
    if ! push_changes; then
        return 1
    fi
    
    success_msg "Opération terminée avec succès!"
    return 0
}

# Lancer le script
main
